# 生产者

## 生产者架构

![生产者架构图](https://github.com/StudyForZX/notes/blob/master/kafka/image/producer_architecture.png)

## 生产者发送消息的三种模式

| 序号 | 模式 | 特点 | 适合场景 |
| :-: | :-: | :-: | :-: |
| 1 | 发后即忘（fire-and-forget）| 吞吐量大，性能最高，但不可靠，消息易丢失 | 可重复的报警等允许少量丢失的场景 |
| 2 | 同步（sync） | 性能最差，阻塞进程，可靠，不易丢失 | 对消息强时间顺序依赖的场景（单partition前提） |
| 3 | 异步（async） | 性能差，调用回调函数前一直阻塞进程，可靠，不易丢失 | 对消息顺序没有强依赖的 |

## 消息发送过程

整个生产者客户端由两个线程协调运行，分别为`主线程`和`sender`线程（发送线程）。

kafka生产者客户端（消息 -> 拦截器（非必须）-> 序列化器 -> 分区器 -> 消息累加器 -> sender线程）-> kafka

## 生产者拦截器

1. 可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要 求的消息、修改消息的内容等。
2. 可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。

## 序列化

生产者需要用序列化器（Serializer）`对象`转换成`字节数组`才能通过网络发送给Kafka。
消费者需要用反序列化器（Deserializer）把从kafka中收到的`字节数组`转成相应的`对象`。

生产者使用的序列化器和消费者使用的反序列化器（有多种）是需要一一对应的。

## 分区器

分区器决定消息发送到哪个分区。

如果消息`ProducerRecord`中指定了`partition`字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。

## 消息累加器

主要用来缓存消息以便Sender线程可以批量发送，进而减少网络传输的资源消耗以提升性能。

### 参数控制

#### `buffer.memory`

限制缓冲最多能占用多大内存，默认32M。

#### `batch.size`

限制每个缓冲批次多大，默认16K。

#### `max.block.ms`

默认60s。

生产者发送消息的速度超过发送到服务器的速度，会导致生产者空间不足，这时生产者要么被阻塞要么发生异常，取决于参数的配置。

### 过程

1. 主线程发送过来的消息都会被追加到`消息累加器`的某个`双端队列`中（在`消息累加器`的内部为每个分区都维护了一个双端队列，队列的内容就是ProducerBatch，即Deque\<ProducerBatch\>）。
2. 消息写入缓存时，追加到双端队列的尾部，Sender读取消息时，从双端队列的头部读取。

## 元数据更新

