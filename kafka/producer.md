# 生产者

## 1. 生产者架构

![生产者架构图](https://github.com/StudyForZX/notes/blob/master/kafka/image/producer_architecture.png)

## 2. 生产者发送消息的三种模式

| 序号 | 模式 | 特点 | 适合场景 |
| :-: | :-: | :-: | :-: |
| 1 | 发后即忘（fire-and-forget）| 吞吐量大，性能最高，但不可靠，消息易丢失 | 可重复的报警等允许少量丢失的场景 |
| 2 | 同步（sync） | 性能最差，阻塞进程，可靠，不易丢失 | 对消息强时间顺序依赖的场景（单partition前提） |
| 3 | 异步（async） | 性能差，调用回调函数前一直阻塞进程，可靠，不易丢失 | 对消息顺序没有强依赖的 |

## 3. 消息发送过程

整个生产者客户端由两个线程协调运行，分别为`主线程`和`sender`线程（发送线程）。

kafka生产者客户端（消息 -> 拦截器（非必须）-> 序列化器 -> 分区器 -> 消息累加器 -> sender线程）-> kafka

## 4. 生产者拦截器

1. 可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要 求的消息、修改消息的内容等。
2. 可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。

## 5. 序列化

生产者需要用序列化器（Serializer）`对象`转换成`字节数组`才能通过网络发送给Kafka。
消费者需要用反序列化器（Deserializer）把从kafka中收到的`字节数组`转成相应的`对象`。

生产者使用的序列化器和消费者使用的反序列化器（有多种）是需要一一对应的。

## 6. 分区器

分区器决定消息发送到哪个分区。

如果消息`ProducerRecord`中指定了`partition`字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。

## 7. 消息累加器

主要用来缓存消息以便Sender线程可以批量发送，进而减少网络传输的资源消耗以提升性能。

### 7.1 参数控制

#### `buffer.memory`

限制缓冲最多能占用多大内存，默认32M。

#### `batch.size`

限制每个缓冲批次多大，默认16K。

#### `max.block.ms`

默认60s。

生产者发送消息的速度超过发送到服务器的速度，会导致生产者空间不足，这时生产者要么被阻塞要么发生异常，取决于参数的配置。

### 7.2 过程

1. 主线程发送过来的消息都会被追加到`消息累加器`的某个`双端队列`中（在`消息累加器`的内部为每个分区都维护了一个双端队列，队列的内容就是ProducerBatch，即Deque\<ProducerBatch\>）。
2. 消息写入缓存时，追加到双端队列的尾部，Sender读取消息时，从双端队列的头部读取。

## 8. 元数据更新

### 8.1 概念

> 元数据是指kafka集群的元数据，这些元数据具体记录了集群中有哪些主题，这些主题有哪些分区，每个分区的`leader`副本分配在哪个节点上，`follower`副本分配在哪些节点上，哪些副本在`AR`、`ISR`等集合中，集群中有哪些节点，控制节点又是哪一个等信息。

1. `kafka`要将消息追加到指定主题的某个分区所对应的`leader`副本之前，首先要知道主题的分区数量，然后经过计算得出（或者直接指定）目标分区，之后`KafkaProducer`需要知道目标分区的`leader`副本所在的`broker`节点的地址、端口等信息才能建立连接，最终才能将消息发送到`kafka`，在这一过程中所需要的信息都属于元数据信息。
2. `bootstrap.servers`参数只需要配置部分`broker`节点的地址即 可，不需要配置所有`broker`节点的地址，因为客户端可以自己发现其他`broker`节点的地址，这一过程也属于元数据相关的更新操作。

元数据的更新操作是在客户端内部进行的，对客户端的外部使用者不可见。当需要更新元数据时，会先挑选出`leastLoadedNode`, 然后向这个`Node`发送 MetadataRequest请求来获取具体的元数据信息。

#### leastLoadedNode

即所有`Node`中负载最小的那一个。负载最小的是通过未确认的请求决定的，未确认的请求越多则认为负载越大。

### 8.2 影响参数

#### `rnetadata.rnax.age.rns`

默认300000，即5分钟。

## 9 重要的生产者参数

### `acks`

这个参数用来指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的。`acks`是生产者客户端中一个非常重要的参数，它涉及消息的可靠性和吞吐量之间的权衡。

1. `acks=1`。默认值为`1`。生产者发送消息后，只要分区的leader副本成功写入消息，那么它就会收到来自服务端的成功响应。如果消息无法写入leader副本，比如在leader副本崩溃、重新选举新的leader副本的过程中，那么生产者就会收到一个错误的响应，为了避免消息丢失，生产者可以选择重发消息。如果消息写入leader副本并返回成功响应给生产者，且在被其他`follower`副本拉取之前leader副本崩溃，那么此时消息还是会丢失，因为新选举的leader副本中并没有这条对应的消息。`acks`设置为`1`，是可靠性和吞吐量之间的折中方案。
2. `acks=0`。生产者发送消息之后不需要等待任何服务端的响应。如果在消息从发送到写入kafka的过程中出现某些异常，导致kafka没有收到这条消息，那么生产者也无从得知，消息就丢失了。相同配置下，此配置可以达到最大吞吐量。
3. `acks=-1`或`acks=all`。生产者在消息发送成功之后，需要等待ISR中的所有副本都成功写入消息之后才能收到服务端的成功响应。在其他配置相同的情况下，此配置的可靠型最强。但并不意味着消息就一定可靠，因为`ISR`中可能只有`leader`副本了，这样就退化成了`acks=1`的情况。要获取更高的消息可靠性需要配合`min.insync.replicas`等参数的联动。

### `max.request.size`

用于限制生产者客户端能发送的消息的最大值，默认值为1048576B，即1MB。不建议读者盲目地增大这个参数的配置值，尤其是在对`Kafka`整体脉络没有足够把控的时候。因为这个参数还涉及一些其他参数的联动，比如`broker`端的`message.max.bytes`参数，如果配置错误可能会引起一些不必要的异常。比如将broker端的`message.max.bytes`参数配置为`10`，而`max.request.size`参数配置为`20`，那么当我们发送一条大小为`15B`的消息时，生产者客户端就会报出如下的异常: `org.apache.kafka.common.errors.RecordTooLargeException: The request included a message larger than the max message size the server will accept.`

### `etries`

用来配置生产者重试的次数，默认值为`0`，即在发生异常的时候不进行任何 重试动作。不过并不是所有的异常都是可以通过重试来解决的，比如消息太大，超过 `max.request.size`参数配置的值时，这种方式就不可行了。

### `retry.backoff.ms`

默认值`100`。用于设定两次重试之间的时间间隔，避免无效的重试。

### `compression.type`

用于指定消息的压缩方式，默认值为"none"，在默认情况下，消息不会被压缩。该参数还可以被配置为`gzip`、`snappy`、`lz4`。对消息进行压缩可以极大的减少网络传输量、降低网络I/O，从而提高整体的性能。消息压缩是一种使用时间换空间的优化方式，如果对时延有一定要求，则不推荐使用。

### `connections.max.idle.ms`

指定多久之后关闭限制的连接，默认值是540000（ms），即9分钟。

### `linger.ms`

这个参数用来指定生产者发送`ProducerBatch`之前等待更多的消息加入其中的时间，默认值为0。

增大这个参数的值会增加消息的延迟，但是同时能提升一定的吞吐量。这个linger.ms参数与TCP协议中的Nagle算法有异曲同工之妙。

### `receive.buffer.bytes`

用于设置`socket`接受消息缓冲区（SO_RECBUF）的大小，默认值为32768B，即32K。如果设置为`-1`，则使用操作系统默认值。如果 Producer与 Kafka处于不同的机房， 则可以 适地调大这个参数值 。

### `send.buffer.bytes`

这个参数用来设置`socket`发送缓冲区（SO_SNDBUF）的大小，默认值为131072B，即128K。设置为`-1`则使用操作系统默认值。

### `request.timeout.ms`

用于设置生产者等待请求响应的最长时间，默认值为30000ms。请求超时后可以选择重试。注意这个参数需要比`broker`端参数`replica.lag.time.max.ms`的值要大，这样可以减少因客户端重试而引起的消息重复的概率。

